import { ITransport } from './transports/transports';
import Cdp from './cdp';
export interface IProtocolCommand {
    id?: number;
    method: string;
    params: object;
    sessionId?: string;
}
export interface IProtocolError {
    id: number;
    method?: string;
    error: {
        code: number;
        message: string;
    };
    sessionId?: string;
}
export interface IProtocolSuccess {
    id: number;
    result: object;
    sessionId?: string;
}
declare type ProtocolMessage = IProtocolCommand | IProtocolSuccess | IProtocolError;
/**
 * The Connection provides a high-level wrapper for the underlying Transport.
 */
export declare class Connection {
    private readonly transport;
    /**
     * Gets the API used to talk to CDP.
     */
    readonly api: Cdp.Api;
    private lastId;
    private pauseQueue?;
    private readonly callbacks;
    private readonly innerEmitter;
    private readonly commandEmitter;
    private readonly replyEmitter;
    /**
     * Emitter that fires if an error happens on the underlying transport.
     */
    readonly onError: import("cockatiel").Event<Error>;
    /**
     * Emitter that fires when the underlying connection is closed.
     */
    readonly onEnd: import("cockatiel").Event<void>;
    /**
     * Emitter that fires when any command is received, on addition to any
     * listener set up through the `.api`.
     */
    readonly onCommand: import("cockatiel").Event<IProtocolCommand>;
    /**
     * Emitter that fires when any command reply is received.
     */
    readonly onReply: import("cockatiel").Event<IProtocolError | IProtocolSuccess>;
    constructor(transport: ITransport);
    /**
     * Pauses receiving events, queuing them until unpause is called.
     */
    pause(): void;
    /**
     * Unpauses the event queue, firing any ones that have built up.
     */
    unpause(): void;
    /**
     * Returns a new unique ID for a message, incrementing the internal ID counter.
     */
    getId(): number;
    /**
     * Low-level send command.
     */
    send(message: ProtocolMessage): void;
    /**
     * Makes a call to the given method over CDP. Note that you should generally
     * use `.api` for a better, typed interface to this.
     */
    call<T>(method: string, params: object): Promise<T>;
    /**
     * Closes the underlying transport. Cancels any outstanding callbacks.
     */
    close(): Promise<void>;
    private createDomain;
    private processResponse;
}
export {};
