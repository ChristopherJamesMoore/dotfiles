"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const cdp_error_1 = require("./cdp-error");
const cockatiel_1 = require("cockatiel");
/**
 * The Connection provides a high-level wrapper for the underlying Transport.
 */
class Connection {
    constructor(transport) {
        this.transport = transport;
        /**
         * Gets the API used to talk to CDP.
         */
        this.api = new Proxy({}, {
            get: (target, domain) => { var _a; return (target[domain] = (_a = target[domain], (_a !== null && _a !== void 0 ? _a : this.createDomain(domain)))); },
        });
        this.lastId = 0;
        this.callbacks = new Map();
        this.innerEmitter = new events_1.EventEmitter();
        this.commandEmitter = new cockatiel_1.EventEmitter();
        this.replyEmitter = new cockatiel_1.EventEmitter();
        /**
         * Emitter that fires if an error happens on the underlying transport.
         */
        this.onError = this.transport.onError;
        /**
         * Emitter that fires when the underlying connection is closed.
         */
        this.onEnd = this.transport.onEnd;
        /**
         * Emitter that fires when any command is received, on addition to any
         * listener set up through the `.api`.
         */
        this.onCommand = this.commandEmitter.addListener;
        /**
         * Emitter that fires when any command reply is received.
         */
        this.onReply = this.replyEmitter.addListener;
        transport.onMessage(msg => this.processResponse(msg));
    }
    /**
     * Pauses receiving events, queuing them until unpause is called.
     */
    pause() {
        this.pauseQueue = this.pauseQueue || [];
    }
    /**
     * Unpauses the event queue, firing any ones that have built up.
     */
    unpause() {
        console.log('process', this.pauseQueue);
        if (!this.pauseQueue) {
            return;
        }
        const queue = this.pauseQueue;
        this.pauseQueue = undefined;
        for (const item of queue) {
            this.processResponse(item);
        }
    }
    /**
     * Returns a new unique ID for a message, incrementing the internal ID counter.
     */
    getId() {
        return this.lastId++;
    }
    /**
     * Low-level send command.
     */
    send(message) {
        this.transport.send(message);
    }
    /**
     * Makes a call to the given method over CDP. Note that you should generally
     * use `.api` for a better, typed interface to this.
     */
    call(method, params) {
        const id = this.lastId++;
        const message = { id, method, params };
        this.transport.send(message);
        return new Promise((resolve, reject) => {
            this.callbacks.set(id, { resolve, reject });
        });
    }
    /**
     * Closes the underlying transport. Cancels any outstanding callbacks.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.transport.close();
            for (const { reject } of this.callbacks.values()) {
                reject(new cockatiel_1.TaskCancelledError('CDP connection closed'));
            }
            this.callbacks.clear();
        });
    }
    createDomain(domain) {
        return new Proxy({}, {
            get: (_target, method) => {
                if (method === 'on') {
                    return (eventName, listener) => {
                        const evt = `${domain}.${eventName}`;
                        this.innerEmitter.on(evt, listener);
                        return () => this.innerEmitter.off(evt, listener);
                    };
                }
                return (params) => this.call(`${domain}.${method}`, params);
            },
        });
    }
    processResponse(message) {
        if (this.pauseQueue) {
            this.pauseQueue.push(message);
        }
        if (message.id === undefined) {
            // for some reason, TS doesn't narrow this even though IProtocolCommand
            // is the only type of the tuple where id can be undefined.
            const asCommand = message;
            this.commandEmitter.emit(asCommand);
            this.innerEmitter.emit(asCommand.method, asCommand.params);
            return;
        }
        this.replyEmitter.emit(message);
        const callback = this.callbacks.get(message.id);
        if (!callback) {
            return;
        }
        this.callbacks.delete(message.id);
        if ('error' in message) {
            callback.reject(new cdp_error_1.CdpError(message));
        }
        else if ('result' in message) {
            callback.resolve(message.result);
        }
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map