"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const WebSocket = require("ws");
const cockatiel_1 = require("cockatiel");
class WebSocketError extends Error {
    constructor(cause) {
        super(cause.message);
        this.cause = cause;
    }
}
exports.WebSocketError = WebSocketError;
/**
 * A WebSocket-based transports. Can connect to a URL via
 * {@link WebSocketTransport.create} or be created from a {@link WebSocket}
 * received by other means.
 */
class WebSocketTransport {
    constructor(ws) {
        this.endEmitter = new cockatiel_1.EventEmitter();
        this.messageEmitter = new cockatiel_1.EventEmitter();
        this.errorEmitter = new cockatiel_1.EventEmitter();
        /**
         * @inheritdoc
         */
        this.onMessage = this.messageEmitter.addListener;
        /**
         * @inheritdoc
         */
        this.onError = this.errorEmitter.addListener;
        /**
         * @inheritdoc
         */
        this.onEnd = this.endEmitter.addListener;
        this.ws = ws;
        this.ws.addEventListener('message', event => {
            this.messageEmitter.emit(JSON.parse(event.data));
        });
        this.ws.addEventListener('close', () => {
            this.endEmitter.emit();
        });
        this.ws.addEventListener('error', error => {
            this.errorEmitter.emit(new WebSocketError(error));
        });
    }
    /**
     * Creates a new websocket transport connecting to the given URL.
     */
    static create(url, cancellationToken = cockatiel_1.CancellationToken.None) {
        return __awaiter(this, void 0, void 0, function* () {
            const ws = new WebSocket(url, [], {
                perMessageDeflate: false,
                maxPayload: 256 * 1024 * 1024,
            });
            return yield new Promise((resolve, reject) => {
                const onCancel = cancellationToken.onCancellationRequested(() => {
                    ws.close();
                    reject(new cockatiel_1.TaskCancelledError());
                });
                ws.addEventListener('open', () => {
                    resolve(new WebSocketTransport(ws));
                    onCancel.dispose();
                });
                ws.addEventListener('error', () => {
                    reject();
                    onCancel.dispose();
                });
            });
        });
    }
    /**
     * @inheritdoc
     */
    send(message) {
        var _a;
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(message));
    }
    /**
     * @inheritdoc
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ws) {
                return;
            }
            let callback;
            const result = new Promise(f => (callback = f));
            this.ws.addEventListener('close', () => callback());
            this.ws.close();
            this.ws = undefined;
            return result;
        });
    }
}
exports.WebSocketTransport = WebSocketTransport;
//# sourceMappingURL=websocket.js.map