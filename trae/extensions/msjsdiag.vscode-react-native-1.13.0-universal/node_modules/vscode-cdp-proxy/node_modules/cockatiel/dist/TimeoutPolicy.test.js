"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const util_1 = require("util");
const defer_1 = require("./common/defer");
const util_test_1 = require("./common/util.test");
const TaskCancelledError_1 = require("./errors/TaskCancelledError");
const Policy_1 = require("./Policy");
const TimeoutPolicy_1 = require("./TimeoutPolicy");
const delay = util_1.promisify(setTimeout);
describe('TimeoutPolicy', () => {
    it('works when no timeout happens', async () => {
        const policy = Policy_1.Policy.timeout(1000, TimeoutPolicy_1.TimeoutStrategy.Cooperative);
        chai_1.expect(await policy.execute(() => 42)).to.equal(42);
    });
    it('properly cooperatively cancels', async () => {
        const policy = Policy_1.Policy.timeout(2, TimeoutPolicy_1.TimeoutStrategy.Cooperative);
        chai_1.expect(await policy.execute(async ({ cancellation }) => {
            chai_1.expect(cancellation.isCancellationRequested).to.be.false;
            await delay(3);
            chai_1.expect(cancellation.isCancellationRequested).to.be.true;
            return 42;
        })).to.equal(42);
    });
    it('properly aggressively cancels', async () => {
        const policy = Policy_1.Policy.timeout(5, TimeoutPolicy_1.TimeoutStrategy.Aggressive);
        const verified = defer_1.defer();
        await chai_1.expect(policy.execute(async ({ cancellation }) => {
            await delay(0);
            chai_1.expect(cancellation.isCancellationRequested).to.be.false;
            await delay(5);
            chai_1.expect(cancellation.isCancellationRequested).to.be.true;
            verified.resolve(undefined);
            return 42;
        })).to.eventually.be.rejectedWith(TaskCancelledError_1.TaskCancelledError);
        await verified.promise;
    });
    it('does not unref by default', async () => {
        // this would timeout if the timers were referenced
        const output = await util_test_1.runInChild(`
      Policy.timeout(100, 'aggressive')
        .execute(() => new Promise(() => {}));
    `);
        chai_1.expect(output).to.contain('Operation cancelled');
    });
    it('unrefs as requested', async () => {
        // this would timeout if the timers were referenced
        const output = await util_test_1.runInChild(`
      Policy.timeout(60 * 1000, 'aggressive')
        .dangerouslyUnref()
        .execute(() => new Promise(() => {}));
    `);
        chai_1.expect(output).to.be.empty;
    });
});
//# sourceMappingURL=TimeoutPolicy.test.js.map