import { CancellationTokenSource } from './CancellationToken';
import { EventEmitter } from './common/Event';
import { TaskCancelledError } from './errors/TaskCancelledError';
export var TimeoutStrategy;
(function (TimeoutStrategy) {
    /**
     * Cooperative timeouts will simply revoke the inner cancellation token,
     * assuming the caller handles cancellation and throws or returns appropriately.
     */
    TimeoutStrategy["Cooperative"] = "optimistic";
    /**
     * Aggressive cancellation immediately throws
     */
    TimeoutStrategy["Aggressive"] = "aggressive";
})(TimeoutStrategy || (TimeoutStrategy = {}));
export class TimeoutPolicy {
    constructor(duration, strategy, unref = false) {
        this.duration = duration;
        this.strategy = strategy;
        this.unref = unref;
        this.timeoutEmitter = new EventEmitter();
        /**
         * Event that fires when a function times out.
         */
        // tslint:disable-next-line: member-ordering
        this.onTimeout = this.timeoutEmitter.addListener;
    }
    /**
     * When timing out, a referenced timer is created. This means the Node.js
     * event loop is kept active while we're waiting for the timeout, as long as
     * the function hasn't returned. Calling this method on the timeout builder
     * will unreference the timer, allowing the process to exit even if a
     * timeout might still be happening.
     */
    dangerouslyUnref() {
        const t = new TimeoutPolicy(this.duration, this.strategy, true);
        t.onTimeout(() => this.timeoutEmitter.emit());
        return t;
    }
    /**
     * Executes the given function.
     * @param fn -- Function to execute. Takes in a nested cancellation token.
     * @throws a {@link TaskCancelledError} if a timeout occurs
     */
    async execute(fn) {
        const cts = new CancellationTokenSource();
        const timer = setTimeout(() => cts.cancel(), this.duration);
        if (this.unref) {
            timer.unref();
        }
        try {
            if (this.strategy === TimeoutStrategy.Cooperative) {
                return await fn({ cancellation: cts.token });
            }
            return await Promise.race([
                fn({ cancellation: cts.token }),
                cts.token.cancellation(cts.token).then(() => {
                    throw new TaskCancelledError(`Operation timed out after ${this.duration}ms`);
                }),
            ]);
        }
        finally {
            cts.cancel();
            clearTimeout(timer);
        }
    }
}
//# sourceMappingURL=TimeoutPolicy.js.map